TestCoefficients := module()
option package;
export Run, ModuleApply;
local Tests;

# Syntax: [partitions, <other arguments>, expected value, number of repetitions]
Tests := [];


##############################################################################
# 2 x 2 x 2
##############################################################################
Tests := [seq(Tests),
  [[[1, 1], [1, 1], [1, 1]], 0, 5],
  [[[2, 2], [2, 2], [2, 2]], 1, 5],
  [[[1, 1], [1, 1], [1, 1]], k, (1/2)*(-1)^k+1/2, 5],
  [[[1, 1], [1, 1], [1, 1]], coset=0, k, 1, 5],
  [[[1, 1], [1, 1], [1, 1]], coset=1, k, 0, 5],
  [[[2, 1], [2, 1], [2, 1]], 1, 5],
  [[[2, 1], [2, 1], [2, 1]], k, (1/2)*k+3/4+(1/4)*(-1)^k, 5],
  [[[2, 1], [2, 1], [2, 1]], [lambda, mu, nu], forceperturb=true, -(1/2)*mu[1]+(1/2)*lambda[2]-(1/2)*nu[1]+3/4+lambda[1]+(1/4)*(-1)^(mu[1]+lambda[2]+nu[1]), 10],
  LAST
];

##############################################################################
# 4 x 2 x 2
##############################################################################
Tests := [seq(Tests),
  [[[131, 39, 19, 11], [110, 90], [120, 80]], 70, 10],
  [[[132, 38, 19, 11], [110, 90], [120, 80]], 65, 10],
  [[[13, 4, 2, 1], [11, 9], [12, 8]], 3, 10],
  [[[5, 3, 2, 1], [6, 5], [6, 5]], 1, 10],
  [[[5, 3, 2, 1], [6, 5], [6, 5]], k, (1/4)*k^2+5/8+(3/8)*(-1)^k+(1/2)*k, 5],
  [[[10, 6, 2], [10, 8], [11, 7]], k, (7*k^2 + 6*k + 4 - 5 * (1 - (-1)^k) / 2) / 4, 5],   # Briand-Orellana-Rosas (page 8 of arXiv:0810.3163)
  [[[10, 6, 2], [10, 8], [11, 7]], k, coset=0, (7*k^2 + 6*k + 4) / 4, 5],
  [[[10, 6, 2], [10, 8], [11, 7]], k, coset=1, (7*k^2 + 6*k - 1) / 4, 5],
  [[[132, 38, 19, 11], [110, 90], [120, 80]], [lambda, mu, nu], (1/8)*(-1)^(lambda[4]+mu[1]+lambda[2]+nu[1])+3/4+(1/2)*lambda[3]*mu[1]+(1/2)*lambda[3]*lambda[2]+(1/4)*lambda[4]^2+(1/2)*lambda[4]*nu[1]-(1/2)*lambda[4]*mu[1]-(1/2)*lambda[4]*lambda[2]-(1/4)*lambda[3]^2-(1/2)*lambda[3]*nu[1]+(1/2)*mu[1]-(1/2)*nu[1]+(1/2)*lambda[2]+(1/2)*lambda[3]-lambda[4]+(1/8)*(-1)^(lambda[3]+mu[1]+lambda[2]+nu[1]), 5],
  [[[5, 3, 2, 1], [6, 5], [6, 5]], [lambda, mu, nu], forceperturb=true, 1/2+(1/2)*lambda[3]*mu[1]-(1/2)*lambda[3]*lambda[1]+(1/2)*lambda[3]*nu[1]+(1/2)*mu[1]*lambda[1]+lambda[2]*mu[1]-(3/4)*lambda[3]^2-(1/2)*nu[1]^2-(1/2)*lambda[4]*lambda[2]+(1/8)*(-1)^(lambda[4]+mu[1]+lambda[3]+nu[1])+(1/8)*(-1)^(lambda[4]+mu[1]+lambda[2]+nu[1])+(1/8)*(-1)^(lambda[3]+mu[1]+lambda[2]+nu[1])+(1/8)*(-1)^(lambda[3]+mu[1]+lambda[1]+nu[1])-(1/2)*lambda[3]*lambda[2]-(1/2)*lambda[1]-(1/2)*lambda[2]-(1/2)*lambda[3]-(1/2)*lambda[4]+(1/2)*mu[1]+(1/2)*nu[1]-lambda[2]^2-lambda[2]*lambda[1]+lambda[2]*nu[1]-(1/4)*lambda[1]^2+(1/2)*lambda[1]*nu[1]+(1/2)*lambda[4]*lambda[3]-(1/2)*mu[1]^2, 5],
  LAST
];

##############################################################################
# 2 x 2 x 2 x 2
##############################################################################
Tests := [seq(Tests),
  [[[1, 1], [1, 1], [1, 1], [1, 1]], 1, 2],
  [[[2, 1], [2, 1], [2, 1], [2, 1]], 3, 2],
  # [[[1, 1], [1, 1], [1, 1], [1, 1]], k, XXX, 1],   # not so clear how to compare
  [[[1, 1], [1, 1], [1, 1], [1, 1]], k, coset=0, (1/72)*k^3+(1/6)*k^2+(2/3)*k+1, 1],
  [[[1, 1], [1, 1], [1, 1], [1, 1]], k, coset=1, (1/72)*k^3+(1/6)*k^2+(13/24)*k+5/18, 1],
  [[[1, 1], [1, 1], [1, 1], [1, 1]], k, coset=4, (1/72)*k^3+(1/6)*k^2+(2/3)*k+7/9, 1],
LAST];


##############################################################################
# 3 x 3 x 2
##############################################################################
Tests := [seq(Tests),
  [[[3, 2, 1], [3, 2, 1], [6, 0]], 1, 2],
  [[[19, 15, 9], [21, 14, 8], [27, 16]], 757, 2],
  #[[[19, 15, 9], [21, 14, 8], [27, 16]], k, keeptheta=true, XXX, 1],  # not so clear how to compare
LAST];


##############################################################################
# 6 x 3 x 2
##############################################################################
Tests := [seq(Tests),
  [[[288, 192, 174, 120, 30, 6], [343, 270, 197], [654, 156]], 18, 1],
  [[[288, 192, 174, 120, 30, 6], [343, 270, 197], [654, 156]], [lambda, mu, nu], forceperturb = true, 1/5040 * mul(lambda[1] + lambda[2] + lambda[3] - nu[1] + i, i=1..7) * (lambda[1] + lambda[2] + lambda[4] + lambda[5] - mu[1] - mu[2] + 1), 1],
  [[[15, 10, 9, 4, 3, 2], [21, 14, 8], [27, 16]], 148, 1],
  [[[1, 1, 1, 1, 1, 1], [2, 2, 2], [3, 3]], k, 1, 1],
  #[[[15, 10, 9, 4, 3, 2], [21, 14, 8], [27, 16]], k, keeptheta=true, XXX, 1],  # not so clear how to compare
LAST];


##############################################################################
# 3 x 3 x 3
##############################################################################
Tests := [seq(Tests),
  [[[1, 1, 1], [1, 1, 1], [1, 1, 1]], 0, 1],  # 52 secs
  [[[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2, 1, 1],  # 51 secs
  [[[1, 1, 1], [1, 1, 1], [1, 1, 1]], k, coset=0, (1/4)*k+(1/48)*k^2+1, 1],   # 102 secs
  [[[1, 1, 1], [1, 1, 1], [1, 1, 1]], k, coset=4, (1/4)*k+(1/48)*k^2+2/3, 1],   # 104 secs
  [[[3, 2, 1], [3, 2, 1], [3, 2, 1]], 5, 1],    # 256 secs / 302 secs
  [[[400000, 200000, 100000], [500000, 100000, 100000], [300000, 200000, 200000]], 1596403568763802677125206373630515086, 1],    # 353 secs / 282 secs
LAST];


##############################################################################
# 4 x 3 x 3
##############################################################################
Tests := [seq(Tests),
  [[[3, 3, 3, 3], [4, 4, 4],  [4, 4, 4]], 1, 1],   # 550 sec / 204 sec
  [[[3, 3, 3, 3], [4, 4, 4],  [4, 4, 4]], k, coset=1, (41/96)*k+(59/288)*k^2+(1/96)*k^3+(1/576)*k^4+205/576, 1],   # 714 sec / 359 secs
LAST];


##############################################################################
# 2 x 2 x 2 x 2 x 2
##############################################################################
Tests := [seq(Tests),
  #[[[1, 1], [1, 1], [1, 1], [1, 1], [1, 1]], 0, 1],  # this will still be quite slow
  #[[[1, 1], [1, 1], [1, 1], [1, 1], [1, 1]], k, XXX, 1],  # this will still be quite slow
LAST];


##############################################################################
# 4 x 4 x 2
##############################################################################
Tests := [seq(Tests),
  [[[1, 1, 1, 1], [1, 1, 1, 1], [2, 2]], 0, 1],    # 26 secs
  [[[1, 1, 1, 1], [1, 1, 1, 1], [2, 2]], k, coset=0, 1+(1/6)*k, 1],   # 43 secs
  [[[1, 1, 1, 1], [1, 1, 1, 1], [2, 2]], k, coset=7, -1/6+(1/6)*k, 1],   # 47 secs
  #[[[1, 1, 1, 1], [1, 1, 1, 1], [2, 2]], k, XXX, 1], # TODO: why do we get exp(2 Pi I/3 ...) in here?
LAST];


##############################################################################
# Run all tests
##############################################################################
Run := proc({ impl := Kronecker })
  local numTests, test, targs, expected, reps, st, dt, times, g, i;
  numTests := 0;
  for test in Tests do
    # last entry? skip
    if test = LAST then
      next;
    end if;
    numTests := numTests + 1;

    # extract test details
    targs := test[..-3];
    expected := test[-2];
    reps := test[-1];
    printf("g%a = %.30a... (%a repetitions)\n", targs, expected, reps);

    # compute coefficients (several times)
    times := [];
    for i from 1 to reps do
      st := time():
      g := impl(targs[]);
      if simplify(g - expected) <> 0 then
        error("TEST FAILED: Expected %1, got %2", expected, g);
       end if;
      dt := time() - st;
      times := [seq(times), dt];
    end do;

    # print result and statistics
    if reps > 1 then
      printf("  %.02f secs (+/- %.02f)\n", Statistics:-Mean(times), Statistics:-StandardDeviation(times));
    else
      printf("  %.02f secs\n", Statistics:-Mean(times));
    end if;
  end do;

  printf("ALL %d TESTS SUCCEEDED.\n", numTests);
end proc;

ModuleApply := Run;

end module;


TestCoefficients();
